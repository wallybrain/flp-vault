---
phase: 02-grouping
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/src/matcher/mod.rs
  - src-tauri/src/matcher/normalize.rs
  - src-tauri/src/matcher/signals.rs
  - src-tauri/src/matcher/scorer.rs
  - src-tauri/src/matcher/union_find.rs
  - src-tauri/src/services/grouper.rs
  - src-tauri/src/services/mod.rs
autonomous: true
requirements:
  - GRUP-01
  - GRUP-02
  - GRUP-03
  - GRUP-04

must_haves:
  truths:
    - "Fuzzy matcher groups files with similar normalized names into proposals with confidence scores"
    - "BPM agreement boosts confidence; BPM disagreement reduces it"
    - "Files saved close together in time get a temporal confidence boost"
    - "FL Studio 'Save new version' naming (Song 2, Song 22, Song 222) normalizes to the same stem"
    - "Short filenames (< 4 chars normalized) require exact match, not trigram"
    - "Single files with no match above threshold appear as ungrouped proposals"
  artifacts:
    - path: "src-tauri/src/matcher/normalize.rs"
      provides: "Filename normalization with version suffix stripping"
      exports: ["normalize_filename"]
    - path: "src-tauri/src/matcher/signals.rs"
      provides: "BPM and temporal signal functions"
      exports: ["bpm_signal", "temporal_signal"]
    - path: "src-tauri/src/matcher/scorer.rs"
      provides: "Combined confidence scoring"
      exports: ["compute_confidence"]
    - path: "src-tauri/src/matcher/union_find.rs"
      provides: "Disjoint set for transitive group formation"
      exports: ["UnionFind"]
    - path: "src-tauri/src/matcher/mod.rs"
      provides: "Top-level propose_groups function and ProposedGroup type"
      exports: ["propose_groups", "ProposedGroup"]
    - path: "src-tauri/src/services/grouper.rs"
      provides: "Service layer that loads files from DB and calls matcher"
      exports: ["run_grouper"]
  key_links:
    - from: "src-tauri/src/services/grouper.rs"
      to: "src-tauri/src/store/files.rs"
      via: "list_all_files() to load FileRecords"
      pattern: "list_all_files"
    - from: "src-tauri/src/services/grouper.rs"
      to: "src-tauri/src/matcher/mod.rs"
      via: "propose_groups() call"
      pattern: "propose_groups"
    - from: "src-tauri/src/matcher/mod.rs"
      to: "src-tauri/src/matcher/scorer.rs"
      via: "compute_confidence for pairwise scoring"
      pattern: "compute_confidence"
---

<objective>
Build the pure Rust fuzzy matcher module that proposes file groups from scanned FileRecords using trigram similarity, BPM agreement, and temporal clustering signals. This is a TDD plan: tests first, then implementation.

Purpose: The matcher is the core algorithmic component of Phase 2. It must be pure (no DB access, no filesystem) so it can be unit-tested with synthetic data. The service layer (`grouper.rs`) bridges the matcher to the DB.
Output: A tested `matcher/` module and `services/grouper.rs` that produces `Vec<ProposedGroup>` from the files table.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-grouping/02-RESEARCH.md

<interfaces>
<!-- Key types from Phase 1 that this plan depends on. -->

From src-tauri/src/store/files.rs:
```rust
#[derive(Debug, Clone, Serialize)]
pub struct FileRecord {
    pub hash: String,
    pub path: String,
    pub file_size: i64,
    pub mtime: i64,
    pub bpm: Option<f64>,
    pub channel_count: Option<i64>,
    pub plugins_json: Option<String>,
    pub fl_version: Option<String>,
}
```

From src-tauri/src/store/files.rs:
```rust
pub fn list_all_files(db: &Mutex<Connection>) -> Vec<FileRecord>
```

From src-tauri/src/state.rs:
```rust
pub struct AppState {
    pub db: Arc<Mutex<Connection>>,
    pub scan_status: Mutex<ScanStatus>,
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create matcher module with normalize + signals + scorer + union-find (TDD: RED then GREEN)</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/matcher/mod.rs
    src-tauri/src/matcher/normalize.rs
    src-tauri/src/matcher/signals.rs
    src-tauri/src/matcher/scorer.rs
    src-tauri/src/matcher/union_find.rs
  </files>
  <action>
    **Step 1: Add crate dependencies to Cargo.toml:**
    ```toml
    trigram = "0.4"
    uuid = { version = "1", features = ["v4"] }
    ```
    Note: `strsim` is NOT needed — the `trigram` crate alone provides pg_trgm-equivalent similarity which is sufficient for our use case.

    **Step 2: Create test scaffolds first (RED phase).** Write tests in `#[cfg(test)] mod tests` blocks within each file BEFORE writing implementation. Tests must fail initially.

    **normalize.rs** — `pub fn normalize_filename(path: &str) -> String`
    - Strip file extension, extract stem, lowercase
    - Strip ALL trailing digit clusters in a loop (handles FL Studio double-numbering: "Trap Beat 2" and "Trap Beat 22" and "Trap Beat 222" all normalize to "trap beat")
    - Strip trailing `_` and ` ` between digit removal passes
    - Strip common noise suffixes: `_final`, `_old`, `_backup`, `_copy`, ` final`, ` old`, ` backup`
    - Trim whitespace

    Tests for normalize.rs (write these FIRST):
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_basic_normalization() {
            assert_eq!(normalize_filename("Song Name.flp"), "song name");
        }

        #[test]
        fn test_strip_version_number() {
            assert_eq!(normalize_filename("Song Name 2.flp"), "song name");
        }

        #[test]
        fn test_strip_double_version_number() {
            // FL Studio appends digit to existing digit: "Song 2" -> "Song 22"
            assert_eq!(normalize_filename("Trap Beat 22.flp"), "trap beat");
        }

        #[test]
        fn test_strip_triple_version_number() {
            assert_eq!(normalize_filename("Trap Beat 222.flp"), "trap beat");
        }

        #[test]
        fn test_strip_underscore_version() {
            assert_eq!(normalize_filename("Song Name_3.flp"), "song name");
        }

        #[test]
        fn test_strip_noise_suffixes() {
            assert_eq!(normalize_filename("My Song_final.flp"), "my song");
            assert_eq!(normalize_filename("My Song_backup.flp"), "my song");
            assert_eq!(normalize_filename("My Song_old.flp"), "my song");
            assert_eq!(normalize_filename("My Song_copy.flp"), "my song");
        }

        #[test]
        fn test_full_path_extracts_stem() {
            assert_eq!(normalize_filename("/path/to/Song Name 5.flp"), "song name");
        }

        #[test]
        fn test_empty_after_normalization() {
            // Edge case: name is only digits
            let result = normalize_filename("123.flp");
            assert!(result.is_empty() || result.len() < 4);
        }
    }
    ```

    **signals.rs** — `pub fn bpm_signal(bpm_a: Option<f64>, bpm_b: Option<f64>) -> f32` and `pub fn temporal_signal(mtime_a: i64, mtime_b: i64) -> f32`
    - BPM: same within +-1.0 => +0.15, diff > 5.0 => -0.10, else 0.0, either null => 0.0
    - Temporal: within 3 days => +0.10, 4-14 days => +0.05, else 0.0 (never negative)

    Tests for signals.rs:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_bpm_same() {
            assert_eq!(bpm_signal(Some(128.0), Some(128.0)), 0.15);
        }

        #[test]
        fn test_bpm_close() {
            assert_eq!(bpm_signal(Some(128.0), Some(128.5)), 0.15);
        }

        #[test]
        fn test_bpm_different() {
            assert_eq!(bpm_signal(Some(128.0), Some(140.0)), -0.10);
        }

        #[test]
        fn test_bpm_null() {
            assert_eq!(bpm_signal(None, Some(128.0)), 0.0);
            assert_eq!(bpm_signal(Some(128.0), None), 0.0);
        }

        #[test]
        fn test_temporal_same_day() {
            let t = 1700000000_i64;
            assert_eq!(temporal_signal(t, t + 3600), 0.10);
        }

        #[test]
        fn test_temporal_week_apart() {
            let t = 1700000000_i64;
            assert_eq!(temporal_signal(t, t + 7 * 86400), 0.05);
        }

        #[test]
        fn test_temporal_month_apart() {
            let t = 1700000000_i64;
            assert_eq!(temporal_signal(t, t + 60 * 86400), 0.0);
        }
    }
    ```

    **scorer.rs** — `pub fn compute_confidence(norm_a: &str, norm_b: &str, bpm_a: Option<f64>, bpm_b: Option<f64>, mtime_a: i64, mtime_b: i64) -> f32`
    - Compute trigram similarity via `trigram::similarity()`
    - Add bpm_signal and temporal_signal
    - Clamp result to 0.0..=1.0
    - For short names (< 4 chars after normalization): require exact match for trigram component (return 1.0 if exact, 0.0 if not) instead of trigram::similarity

    Tests for scorer.rs:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_identical_names_high_confidence() {
            let score = compute_confidence("acid bass line", "acid bass line", Some(128.0), Some(128.0), 1700000000, 1700000000);
            assert!(score > 0.9);
        }

        #[test]
        fn test_different_names_low_confidence() {
            let score = compute_confidence("acid bass line", "funky groove master", Some(128.0), Some(90.0), 1700000000, 1700000000);
            assert!(score < 0.4);
        }

        #[test]
        fn test_short_name_exact_match() {
            let score = compute_confidence("hi", "hi", Some(128.0), Some(128.0), 1700000000, 1700000000);
            assert!(score > 0.9);
        }

        #[test]
        fn test_short_name_no_match() {
            let score = compute_confidence("hi", "ho", None, None, 1700000000, 1700000000);
            assert!(score < 0.3);
        }

        #[test]
        fn test_confidence_clamped_to_one() {
            // Even with all boosts, should not exceed 1.0
            let score = compute_confidence("test name", "test name", Some(128.0), Some(128.0), 1700000000, 1700000000);
            assert!(score <= 1.0);
        }
    }
    ```

    **union_find.rs** — `pub struct UnionFind` with methods: `new(n: usize)`, `find(&mut self, x: usize) -> usize`, `union(&mut self, x: usize, y: usize)`, `groups(&mut self) -> HashMap<usize, Vec<usize>>`
    - Standard path-compression + union-by-rank implementation
    - `groups()` returns a map from root representative to all members

    Tests for union_find.rs:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_initial_singleton_groups() {
            let mut uf = UnionFind::new(3);
            let groups = uf.groups();
            assert_eq!(groups.len(), 3);
        }

        #[test]
        fn test_union_merges_groups() {
            let mut uf = UnionFind::new(4);
            uf.union(0, 1);
            uf.union(2, 3);
            let groups = uf.groups();
            assert_eq!(groups.len(), 2);
        }

        #[test]
        fn test_transitive_closure() {
            let mut uf = UnionFind::new(3);
            uf.union(0, 1);
            uf.union(1, 2);
            let groups = uf.groups();
            assert_eq!(groups.len(), 1);
            assert_eq!(groups.values().next().unwrap().len(), 3);
        }
    }
    ```

    **mod.rs** — Define `ProposedGroup` struct and `pub fn propose_groups(files: &[FileRecord], threshold: f32) -> Vec<ProposedGroup>`
    - ProposedGroup: `id: String` (uuid v4), `canonical_name: String`, `confidence: f32`, `file_hashes: Vec<String>`, `is_ungrouped: bool`
    - Algorithm:
      1. Pre-compute normalized names for all files
      2. O(n^2) pairwise: compute_confidence for each pair
      3. For each pair with confidence >= threshold, add edge to UnionFind
      4. Extract groups from UnionFind
      5. For each group: confidence = minimum edge confidence in the group
      6. Canonical name = most common normalized name, tiebreak by oldest mtime
      7. Single-file groups (no edges above threshold) get is_ungrouped = true
    - Return groups sorted by confidence ascending (lowest first for review UI)

    Tests for mod.rs (integration):
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::store::files::FileRecord;

        fn make_record(hash: &str, path: &str, bpm: Option<f64>, mtime: i64) -> FileRecord {
            FileRecord {
                hash: hash.to_string(),
                path: path.to_string(),
                file_size: 1000,
                mtime,
                bpm,
                channel_count: Some(8),
                plugins_json: None,
                fl_version: None,
            }
        }

        #[test]
        fn test_groups_similar_filenames() {
            let files = vec![
                make_record("a", "Acid Bass Line.flp", Some(128.0), 1700000000),
                make_record("b", "Acid Bass Line 2.flp", Some(128.0), 1700086400),
                make_record("c", "Funky Groove.flp", Some(90.0), 1700000000),
            ];
            let groups = propose_groups(&files, 0.65);
            // Should produce 2 groups: one with files a+b, one ungrouped c
            assert_eq!(groups.len(), 2);
            let grouped: Vec<_> = groups.iter().filter(|g| !g.is_ungrouped).collect();
            assert_eq!(grouped.len(), 1);
            assert_eq!(grouped[0].file_hashes.len(), 2);
        }

        #[test]
        fn test_ungrouped_files_marked() {
            let files = vec![
                make_record("a", "Completely Unique Name.flp", None, 1700000000),
                make_record("b", "Another Different Song.flp", None, 1700000000),
            ];
            let groups = propose_groups(&files, 0.65);
            assert!(groups.iter().all(|g| g.is_ungrouped));
        }

        #[test]
        fn test_sorted_by_confidence_ascending() {
            let files = vec![
                make_record("a", "Song A.flp", Some(128.0), 1700000000),
                make_record("b", "Song A 2.flp", Some(128.0), 1700086400),
                make_record("c", "Beat X.flp", Some(90.0), 1700000000),
                make_record("d", "Beat X 2.flp", Some(90.0), 1700000000),
            ];
            let groups = propose_groups(&files, 0.65);
            for i in 1..groups.len() {
                assert!(groups[i].confidence >= groups[i-1].confidence);
            }
        }

        #[test]
        fn test_empty_input() {
            let groups = propose_groups(&[], 0.65);
            assert!(groups.is_empty());
        }
    }
    ```

    **Step 3: Run tests — verify they fail (RED).** Then implement all functions. Then run tests again — verify they pass (GREEN).

    **Step 4: Add `mod matcher;` to main.rs** (just the module declaration, no command wiring yet — that's Plan 02-03).
  </action>
  <verify>
    <automated>cd /home/lwb3/flp-vault/src-tauri && cargo test matcher 2>&1 | tail -20 && cargo test union_find 2>&1 | tail -10</automated>
  </verify>
  <done>
    - All normalize tests pass (8+ tests including FL Studio double-numbering edge case)
    - All signal tests pass (BPM same/diff/null, temporal 3-day/14-day/30-day)
    - All scorer tests pass (high/low confidence, short name fallback, clamp)
    - All union_find tests pass (singleton, merge, transitive closure)
    - Integration tests pass (similar filenames group, ungrouped marked, sorted ascending)
    - `cargo test matcher` and `cargo test union_find` both green
    - `cargo check` succeeds
  </done>
</task>

<task type="auto">
  <name>Task 2: Create grouper service layer bridging matcher to DB</name>
  <files>
    src-tauri/src/services/grouper.rs
    src-tauri/src/services/mod.rs
    src-tauri/src/main.rs
  </files>
  <action>
    **services/grouper.rs**: Implement `pub fn run_grouper(db: &Mutex<Connection>, threshold: f32) -> Vec<ProposedGroup>`:
    1. Call `store::files::list_all_files(db)` to load all FileRecords
    2. Call `matcher::propose_groups(&files, threshold)` to compute proposals
    3. Return the proposals

    This is a thin orchestrator — the matcher is pure and the DB access is isolated.

    **services/mod.rs**: Add `pub mod grouper;` alongside existing `pub mod scanner;`.

    **main.rs**: Add `mod matcher;` declaration (alongside existing mod declarations). Do NOT register any new commands yet — that is Plan 02-03.

    The grouper does NOT need its own thread (unlike scanner) because the O(n^2) computation at n=500 files takes ~250ms — fast enough to run synchronously in a Tauri command handler.
  </action>
  <verify>
    <automated>cd /home/lwb3/flp-vault/src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>
    - `services/grouper.rs` exists with `run_grouper` function
    - `services/mod.rs` exports both `scanner` and `grouper`
    - `main.rs` has `mod matcher;` declaration
    - `cargo check` succeeds
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo test matcher` — all matcher module tests pass
2. `cd src-tauri && cargo test union_find` — union-find tests pass
3. `cd src-tauri && cargo check` — full project compiles
4. `grep -r "propose_groups" src-tauri/src/` confirms function exists and is called from grouper
5. Normalization of "Trap Beat 222.flp" produces "trap beat" (verified by unit test)
</verification>

<success_criteria>
- Pure matcher module with no DB or filesystem dependencies
- Trigram similarity + BPM + temporal signals combine into 0.0-1.0 confidence
- FL Studio version numbering edge case handled (Trap Beat 2/22/222 all normalize same)
- Short filenames (< 4 chars) use exact match instead of trigram
- Union-find produces transitive groups
- Proposals sorted by confidence ascending
- All unit and integration tests pass
- Grouper service bridges matcher to DB via list_all_files
</success_criteria>

<output>
After completion, create `.planning/phases/02-grouping/02-01-SUMMARY.md`
</output>
