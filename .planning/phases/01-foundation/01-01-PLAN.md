---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/tauri.conf.json
  - src-tauri/capabilities/default.json
  - src-tauri/src/main.rs
  - src-tauri/src/state.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/services/mod.rs
  - src-tauri/src/parser/mod.rs
  - src-tauri/src/parser/types.rs
  - src-tauri/src/store/mod.rs
  - src-tauri/src/store/connection.rs
  - src-tauri/src/store/migrations.rs
  - src-tauri/src/store/settings.rs
  - src-tauri/src/store/files.rs
  - src/index.html
  - src/styles/main.css
  - src/js/main.js
  - src/js/api.js
  - package.json
  - .gitignore
autonomous: true
requirements:
  - PARS-06
  - SETT-04

must_haves:
  truths:
    - "Tauri app compiles and opens a window with dark theme"
    - "SQLite database is created in app data directory on first launch"
    - "Database has files, path_index, and settings tables with correct schema"
    - "Settings can be read and written via Rust store functions"
  artifacts:
    - path: "src-tauri/Cargo.toml"
      provides: "Rust dependencies for Phase 1"
      contains: "rusqlite"
    - path: "src-tauri/src/main.rs"
      provides: "Tauri app entry point with DB init"
      contains: "tauri::Builder"
    - path: "src-tauri/src/state.rs"
      provides: "AppState with Mutex<Connection>"
      contains: "AppState"
    - path: "src-tauri/src/store/connection.rs"
      provides: "DB init with WAL mode and migrations"
      contains: "journal_mode=WAL"
    - path: "src-tauri/src/parser/types.rs"
      provides: "FlpMetadata and ChannelInfo structs"
      exports: ["FlpMetadata", "ChannelInfo"]
    - path: "src/index.html"
      provides: "Frontend shell with dark theme"
  key_links:
    - from: "src-tauri/src/main.rs"
      to: "src-tauri/src/store/connection.rs"
      via: "init_db() called in setup hook"
      pattern: "init_db"
    - from: "src-tauri/src/main.rs"
      to: "src-tauri/src/state.rs"
      via: "app.manage(AppState)"
      pattern: "app\\.manage"
---

<objective>
Scaffold the Tauri v2 project with Rust workspace, SQLite store with WAL mode, schema migrations, settings persistence, and a minimal dark-theme frontend shell.

Purpose: Establish the foundational project structure that all subsequent plans build on — the Cargo workspace, Tauri config, database layer, shared types, and frontend entry point.
Output: A compiling Tauri app that opens a window, initializes SQLite in %APPDATA%, and has all module stubs in place.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Tauri v2 project scaffold with Cargo.toml and config</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/tauri.conf.json
    src-tauri/capabilities/default.json
    src-tauri/src/main.rs
    src-tauri/src/state.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/services/mod.rs
    src-tauri/src/parser/mod.rs
    src-tauri/src/parser/types.rs
    src-tauri/src/store/mod.rs
    src/index.html
    src/styles/main.css
    src/js/main.js
    src/js/api.js
    package.json
    .gitignore
  </files>
  <action>
    Create the full Tauri v2 project structure manually (do NOT use create-tauri-app — we need precise control).

    **Cargo.toml** with these dependencies:
    ```toml
    [dependencies]
    tauri = { version = "2", features = [] }
    serde = { version = "1", features = ["derive"] }
    serde_json = "1"
    rusqlite = { version = "0.32", features = ["bundled"] }
    walkdir = "2"
    dirs = "5"
    xxhash-rust = { version = "0.8", features = ["xxh3"] }
    chrono = { version = "0.4", features = ["serde"] }
    byteorder = "1"

    [build-dependencies]
    tauri-build = { version = "2", features = [] }
    ```

    **tauri.conf.json**: Set `identifier` to "com.flpvault.app", `productName` to "FLP Vault", `version` to "0.1.0". Set `devUrl` to `"http://localhost:1420"` and `frontendDist` to `"../src"`. Set bundle.windows.webviewInstallMode to `{ "type": "downloadBootstrapper" }`.

    **capabilities/default.json**: Minimal permissions — `core:default` and `core:window:default` only.

    **main.rs**: Tauri builder with setup hook that calls `store::connection::init_db()` using `app.path().app_data_dir()`, creates AppState, registers it with `app.manage()`. Register empty command handler list (commands added in Plan 03). Include `mod commands; mod services; mod parser; mod store; mod state;`.

    **state.rs**: Define `AppState` struct with `db: Arc<Mutex<Connection>>` and `scan_status: Mutex<ScanStatus>`. `ScanStatus` has `total: usize`, `done: usize`, `running: bool`.

    **parser/types.rs**: Define `FlpMetadata` struct with fields: `bpm: Option<f32>`, `time_sig_num: Option<u8>`, `time_sig_den: Option<u8>`, `channel_count: u16`, `pattern_count: u16`, `mixer_track_count: u16`, `generators: Vec<ChannelInfo>`, `effects: Vec<String>`, `fl_version: Option<String>`, `warnings: Vec<String>`. Define `ChannelInfo` with `name: String`, `plugin_name: Option<String>`, `channel_type: u8`. Both structs derive `Debug, Clone, Serialize, Deserialize, Default`.

    **Module stubs**: `commands/mod.rs`, `services/mod.rs`, `parser/mod.rs` (re-exports types), `store/mod.rs` — each with appropriate `pub mod` declarations.

    **Frontend**: `src/index.html` with dark theme shell (background #1a1a2e, text #e0e0e0), loading message. Import `main.js` as module. `src/styles/main.css` with dark theme variables and base styles. `src/js/main.js` as empty entry point. `src/js/api.js` with placeholder for invoke wrappers.

    **package.json**: Name "flp-vault", version "0.1.0", with `@tauri-apps/api` dependency (version ^2).

    **.gitignore**: Include `node_modules/`, `target/`, `src-tauri/target/`, `.env`, `*.db`, `*.db-wal`, `*.db-shm`.

    Also create `src-tauri/build.rs` with `fn main() { tauri_build::build() }`.

    IMPORTANT: This project builds on Linux for development but targets Windows. The Rust code must compile on Linux (for CI checks) even though the Tauri window won't open. Use `#[cfg(target_os = "windows")]` only where absolutely necessary (like Windows-specific path defaults). All path handling should use `std::path::PathBuf` not hardcoded backslashes.
  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>
    - Cargo.toml has all Phase 1 dependencies
    - `cargo check` succeeds without errors
    - All module directories exist with mod.rs files
    - FlpMetadata and ChannelInfo types are defined and exported
    - tauri.conf.json has correct app identity and WebView2 bootstrapper config
    - Frontend files exist with dark theme base
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SQLite store layer with schema, migrations, and settings</name>
  <files>
    src-tauri/src/store/connection.rs
    src-tauri/src/store/migrations.rs
    src-tauri/src/store/settings.rs
    src-tauri/src/store/files.rs
    src-tauri/src/store/mod.rs
  </files>
  <action>
    **connection.rs**: Implement `init_db(app_data_dir: &Path) -> Result<Mutex<Connection>, Box<dyn std::error::Error>>`. CRITICAL: Call `std::fs::create_dir_all(app_data_dir)` BEFORE `Connection::open()` — Tauri does not create the app data dir automatically (known gotcha). Set PRAGMAs: `journal_mode=WAL`, `foreign_keys=ON`, `synchronous=NORMAL`. Call `run_migrations(&conn)`.

    **migrations.rs**: Implement `run_migrations(conn: &Connection)` with the Phase 1 schema:

    ```sql
    CREATE TABLE IF NOT EXISTS files (
        hash         TEXT PRIMARY KEY,
        path         TEXT NOT NULL,
        file_size    INTEGER NOT NULL,
        mtime        INTEGER NOT NULL,
        bpm          REAL,
        time_sig_num INTEGER,
        time_sig_den INTEGER,
        channel_count INTEGER,
        pattern_count INTEGER,
        mixer_track_count INTEGER,
        plugins_json TEXT,
        warnings_json TEXT,
        fl_version   TEXT,
        parsed_at    INTEGER NOT NULL
    );

    CREATE TABLE IF NOT EXISTS path_index (
        path         TEXT PRIMARY KEY,
        hash         TEXT NOT NULL,
        file_size    INTEGER NOT NULL,
        mtime        INTEGER NOT NULL,
        FOREIGN KEY (hash) REFERENCES files(hash)
    );

    CREATE TABLE IF NOT EXISTS settings (
        key   TEXT PRIMARY KEY,
        value TEXT NOT NULL
    );
    ```

    **settings.rs**: Implement `get_setting(db: &Mutex<Connection>, key: &str) -> Option<String>`, `set_setting(db: &Mutex<Connection>, key: &str, value: &str)`, and `get_all_settings(db: &Mutex<Connection>) -> Settings` struct with `source_folder`, `organized_folder`, `originals_folder`. Apply smart defaults if settings are empty: source defaults to FL Studio's default project folder pattern, organized and originals default to "FLP Vault" and "FLP Vault Originals" in Documents. Use `dirs::document_dir()` for cross-platform document folder resolution.

    **files.rs**: Implement `is_cached(db: &Mutex<Connection>, path: &str, file_size: i64, mtime: i64) -> bool` (checks path_index for matching mtime+size), `hash_in_cache(db: &Mutex<Connection>, hash: &str) -> bool`, `update_path_index(db: &Mutex<Connection>, path: &str, hash: &str, file_size: i64, mtime: i64)`, and `upsert_file(db: &Mutex<Connection>, hash: &str, path: &str, file_size: i64, mtime: i64, meta: &FlpMetadata)` which inserts into both `files` and `path_index` tables. Serialize generators+effects as JSON for `plugins_json`. Serialize warnings as JSON for `warnings_json`.

    Also implement `list_all_files(db: &Mutex<Connection>) -> Vec<FileRecord>` for the scan results table. `FileRecord` should contain all fields needed for the UI table: filename, path, bpm, channel_count, plugins summary, mtime.

    **mod.rs**: Re-export all public functions.

    All Mutex locks: acquire, do synchronous DB work, release immediately. Never hold across async boundaries.
  </action>
  <verify>
    <automated>cd src-tauri && cargo check 2>&1 | tail -5</automated>
  </verify>
  <done>
    - `init_db` creates directory and opens SQLite with WAL mode
    - All three tables created via migrations
    - Settings CRUD works (get/set/defaults)
    - File cache functions (is_cached, upsert_file, list_all_files) compile
    - `cargo check` succeeds
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo check` compiles without errors
2. All module files exist in correct directory structure
3. FlpMetadata type is exported from parser module
4. Store connection creates SQLite with WAL mode
5. Settings have smart defaults
</verification>

<success_criteria>
- Tauri project compiles on Linux with `cargo check`
- All Rust modules exist with correct structure (commands/, services/, parser/, store/)
- SQLite schema has files, path_index, and settings tables
- FlpMetadata and ChannelInfo types defined with Serialize/Deserialize
- Frontend shell exists with dark theme
- AppState holds Arc<Mutex<Connection>>
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
