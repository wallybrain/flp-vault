---
phase: 02-grouping
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src-tauri/src/store/migrations.rs
  - src-tauri/src/store/groups.rs
  - src-tauri/src/store/mod.rs
  - src-tauri/src/commands/groups.rs
  - src-tauri/src/commands/mod.rs
  - src-tauri/src/main.rs
autonomous: true
requirements:
  - GRUP-05
  - GRUP-06
  - GRUP-07
  - GRUP-08
  - GRUP-09

must_haves:
  truths:
    - "song_groups and group_files tables exist in SQLite after migration"
    - "propose_groups Tauri command returns group proposals computed from files table"
    - "confirm_groups Tauri command persists confirmed groups atomically in a single transaction"
    - "list_groups Tauri command returns previously confirmed groups"
    - "reset_groups Tauri command clears all confirmed groups"
    - "Grouping threshold is configurable via the settings table (key: grouping_threshold, default: 0.65)"
  artifacts:
    - path: "src-tauri/src/store/groups.rs"
      provides: "CRUD for song_groups and group_files tables"
      exports: ["confirm_group", "list_confirmed_groups", "get_group_for_file", "has_confirmed_groups", "mark_file_ignored", "clear_all_groups"]
    - path: "src-tauri/src/commands/groups.rs"
      provides: "Tauri commands for group operations"
      exports: ["propose_groups", "confirm_groups", "list_groups", "reset_groups"]
    - path: "src-tauri/src/store/migrations.rs"
      provides: "Phase 2 migration adding song_groups and group_files tables"
      contains: "song_groups"
  key_links:
    - from: "src-tauri/src/commands/groups.rs"
      to: "src-tauri/src/services/grouper.rs"
      via: "run_grouper() for propose_groups command"
      pattern: "run_grouper"
    - from: "src-tauri/src/commands/groups.rs"
      to: "src-tauri/src/store/groups.rs"
      via: "confirm_group, list_confirmed_groups, clear_all_groups"
      pattern: "confirm_group|list_confirmed_groups|clear_all_groups"
    - from: "src-tauri/src/main.rs"
      to: "src-tauri/src/commands/groups.rs"
      via: "generate_handler! registration"
      pattern: "propose_groups.*confirm_groups.*list_groups.*reset_groups"
---

<objective>
Add SQLite persistence for confirmed groups and wire up the four new Tauri commands (propose_groups, confirm_groups, list_groups, reset_groups). This connects the matcher (Plan 01) to the review UI (Plan 02) via the IPC layer.

Purpose: Without persistence, confirmed groups are lost on app restart. Without Tauri commands, the frontend cannot invoke the matcher or save results. This plan is the glue between the pure matcher module and the frontend review panel.
Output: Two new SQLite tables, a store/groups.rs module, a commands/groups.rs module, and updated main.rs with all commands registered.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-grouping/02-RESEARCH.md
@.planning/phases/02-grouping/02-01-SUMMARY.md

<interfaces>
<!-- From Plan 02-01: matcher types -->
```rust
// src-tauri/src/matcher/mod.rs
pub struct ProposedGroup {
    pub id: String,
    pub canonical_name: String,
    pub confidence: f32,
    pub file_hashes: Vec<String>,
    pub is_ungrouped: bool,
}
```

<!-- From Plan 02-01: grouper service -->
```rust
// src-tauri/src/services/grouper.rs
pub fn run_grouper(db: &Mutex<Connection>, threshold: f32) -> Vec<ProposedGroup>
```

<!-- From Phase 1: existing store pattern -->
```rust
// src-tauri/src/store/settings.rs (pattern to follow)
pub fn get_setting(db: &Mutex<Connection>, key: &str) -> Option<String>
pub fn set_setting(db: &Mutex<Connection>, key: &str, value: &str)
```

<!-- From Phase 1: AppState -->
```rust
// src-tauri/src/state.rs
pub struct AppState {
    pub db: Arc<Mutex<Connection>>,
    pub scan_status: Mutex<ScanStatus>,
}
```

<!-- From Phase 1: existing main.rs command registration -->
```rust
.invoke_handler(tauri::generate_handler![
    scan_folder,
    cancel_scan,
    get_settings,
    save_settings,
    list_scanned_files,
])
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Phase 2 SQLite migration and store/groups.rs CRUD module</name>
  <files>
    src-tauri/src/store/migrations.rs
    src-tauri/src/store/groups.rs
    src-tauri/src/store/mod.rs
  </files>
  <action>
    **store/migrations.rs**: Append a new `conn.execute_batch()` call to the existing `run_migrations` function. Use `CREATE TABLE IF NOT EXISTS` (idempotent, safe to run on every startup alongside Phase 1 tables):

    ```sql
    CREATE TABLE IF NOT EXISTS song_groups (
        group_id       TEXT PRIMARY KEY,
        canonical_name TEXT NOT NULL,
        confirmed_at   INTEGER NOT NULL,
        is_ignored     INTEGER NOT NULL DEFAULT 0
    );

    CREATE TABLE IF NOT EXISTS group_files (
        hash              TEXT NOT NULL,
        group_id          TEXT NOT NULL,
        is_ignored        INTEGER NOT NULL DEFAULT 0,
        manually_assigned INTEGER NOT NULL DEFAULT 0,
        assigned_at       INTEGER NOT NULL,
        PRIMARY KEY (hash, group_id),
        FOREIGN KEY (hash) REFERENCES files(hash),
        FOREIGN KEY (group_id) REFERENCES song_groups(group_id)
    );
    ```

    **store/groups.rs**: Implement the following functions following the same Mutex<Connection> pattern as files.rs and settings.rs:

    ```rust
    use rusqlite::Connection;
    use serde::{Deserialize, Serialize};
    use std::sync::Mutex;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ConfirmedGroup {
        pub group_id: String,
        pub canonical_name: String,
        pub file_hashes: Vec<String>,
        pub ignored_hashes: Vec<String>,
    }

    #[derive(Debug, Clone, Deserialize)]
    pub struct GroupConfirmation {
        pub canonical_name: String,
        pub file_hashes: Vec<String>,
        pub ignored_hashes: Vec<String>,
    }
    ```

    Functions:
    - `pub fn confirm_groups(db: &Mutex<Connection>, groups: &[GroupConfirmation]) -> Result<(), String>` — wrap entire operation in a single SQLite transaction. For each group: generate UUID v4 for group_id, INSERT into song_groups, INSERT each file hash into group_files. For ignored_hashes, set is_ignored=1 in group_files. Use `chrono::Utc::now().timestamp()` for confirmed_at and assigned_at.
    - `pub fn list_confirmed_groups(db: &Mutex<Connection>) -> Vec<ConfirmedGroup>` — JOIN song_groups with group_files, aggregate file_hashes per group. Return groups sorted by canonical_name.
    - `pub fn get_group_for_file(db: &Mutex<Connection>, hash: &str) -> Option<String>` — return group_id for a file hash (used by Phase 3 organize step).
    - `pub fn has_confirmed_groups(db: &Mutex<Connection>) -> bool` — check if any rows exist in song_groups.
    - `pub fn mark_file_ignored(db: &Mutex<Connection>, hash: &str) -> Result<(), String>` — set is_ignored=1 in group_files for given hash.
    - `pub fn clear_all_groups(db: &Mutex<Connection>) -> Result<(), String>` — DELETE FROM group_files, then DELETE FROM song_groups (in a transaction, respect FK order).

    **CRITICAL: Transaction for confirm_groups.** If any insert fails, the entire batch rolls back:
    ```rust
    let conn = db.lock().unwrap();
    let tx = conn.unchecked_transaction().map_err(|e| e.to_string())?;
    // ... all inserts ...
    tx.commit().map_err(|e| e.to_string())?;
    ```
    Note: Use `unchecked_transaction()` because we already hold the Mutex lock (rusqlite's `transaction()` borrows `&mut self` which conflicts with the lock guard).

    **store/mod.rs**: Add `pub mod groups;` alongside existing modules.

    **Unit tests** in groups.rs:
    ```rust
    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::store::connection::init_db;
        use tempfile::tempdir;

        #[test]
        fn test_confirm_and_list_groups() {
            let dir = tempdir().unwrap();
            let db = init_db(dir.path()).unwrap();
            // Insert a file into files table first (FK requirement)
            {
                let conn = db.lock().unwrap();
                conn.execute(
                    "INSERT INTO files (hash, path, file_size, mtime, parsed_at) VALUES (?1, ?2, ?3, ?4, ?5)",
                    ["abc123", "/test.flp", "1000", "1700000000", "1700000000"],
                ).unwrap();
            }
            let groups = vec![GroupConfirmation {
                canonical_name: "Test Song".to_string(),
                file_hashes: vec!["abc123".to_string()],
                ignored_hashes: vec![],
            }];
            confirm_groups(&db, &groups).unwrap();
            let confirmed = list_confirmed_groups(&db);
            assert_eq!(confirmed.len(), 1);
            assert_eq!(confirmed[0].canonical_name, "Test Song");
            assert_eq!(confirmed[0].file_hashes.len(), 1);
        }

        #[test]
        fn test_has_confirmed_groups() {
            let dir = tempdir().unwrap();
            let db = init_db(dir.path()).unwrap();
            assert!(!has_confirmed_groups(&db));
        }

        #[test]
        fn test_clear_all_groups() {
            let dir = tempdir().unwrap();
            let db = init_db(dir.path()).unwrap();
            {
                let conn = db.lock().unwrap();
                conn.execute(
                    "INSERT INTO files (hash, path, file_size, mtime, parsed_at) VALUES (?1, ?2, ?3, ?4, ?5)",
                    ["abc123", "/test.flp", "1000", "1700000000", "1700000000"],
                ).unwrap();
            }
            let groups = vec![GroupConfirmation {
                canonical_name: "Test".to_string(),
                file_hashes: vec!["abc123".to_string()],
                ignored_hashes: vec![],
            }];
            confirm_groups(&db, &groups).unwrap();
            assert!(has_confirmed_groups(&db));
            clear_all_groups(&db).unwrap();
            assert!(!has_confirmed_groups(&db));
        }
    }
    ```
  </action>
  <verify>
    <automated>cd /home/lwb3/flp-vault/src-tauri && cargo test groups 2>&1 | tail -15</automated>
  </verify>
  <done>
    - migrations.rs creates song_groups and group_files tables
    - store/groups.rs has all 6 CRUD functions
    - confirm_groups uses a single SQLite transaction
    - Unit tests pass: confirm+list round-trip, has_confirmed_groups, clear_all_groups
    - store/mod.rs exports groups module
    - `cargo test groups` passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Create commands/groups.rs Tauri commands and register in main.rs</name>
  <files>
    src-tauri/src/commands/groups.rs
    src-tauri/src/commands/mod.rs
    src-tauri/src/main.rs
  </files>
  <action>
    **commands/groups.rs**: Create four Tauri commands:

    ```rust
    use crate::state::AppState;
    use crate::services::grouper;
    use crate::store::{groups, settings};
    use crate::matcher::ProposedGroup;
    use crate::store::groups::GroupConfirmation;
    use tauri::State;

    #[tauri::command]
    pub fn propose_groups(state: State<'_, AppState>) -> Result<Vec<ProposedGroup>, String> {
        // Read grouping_threshold from settings, default to 0.65
        let threshold = settings::get_setting(&state.db, "grouping_threshold")
            .and_then(|s| s.parse::<f32>().ok())
            .unwrap_or(0.65);
        Ok(grouper::run_grouper(&state.db, threshold))
    }

    #[tauri::command]
    pub fn confirm_groups(
        groups_input: Vec<GroupConfirmation>,
        state: State<'_, AppState>,
    ) -> Result<(), String> {
        groups::confirm_groups(&state.db, &groups_input)
    }

    #[tauri::command]
    pub fn list_groups(state: State<'_, AppState>) -> Result<Vec<groups::ConfirmedGroup>, String> {
        Ok(groups::list_confirmed_groups(&state.db))
    }

    #[tauri::command]
    pub fn reset_groups(state: State<'_, AppState>) -> Result<(), String> {
        groups::clear_all_groups(&state.db)
    }
    ```

    **commands/mod.rs**: Add `pub mod groups;` and re-export the four command functions:
    ```rust
    pub use groups::{propose_groups, confirm_groups, list_groups, reset_groups};
    ```

    **main.rs**: Update the use statement and invoke_handler to include the new commands:
    ```rust
    use commands::{
        cancel_scan, get_settings, list_scanned_files, save_settings, scan_folder,
        propose_groups, confirm_groups, list_groups, reset_groups,
    };
    ```

    And in the builder:
    ```rust
    .invoke_handler(tauri::generate_handler![
        scan_folder,
        cancel_scan,
        get_settings,
        save_settings,
        list_scanned_files,
        propose_groups,
        confirm_groups,
        list_groups,
        reset_groups,
    ])
    ```

    **Configurable threshold**: The `propose_groups` command reads `grouping_threshold` from the settings table. If not set, it defaults to 0.65. This means users (or a future settings UI addition) can adjust the threshold by calling `save_settings` with a `grouping_threshold` key — no code change required.
  </action>
  <verify>
    <automated>cd /home/lwb3/flp-vault/src-tauri && cargo check 2>&1 | tail -5 && grep -c "propose_groups\|confirm_groups\|list_groups\|reset_groups" src/main.rs</automated>
  </verify>
  <done>
    - commands/groups.rs has 4 Tauri commands (propose_groups, confirm_groups, list_groups, reset_groups)
    - commands/mod.rs re-exports all 4 commands
    - main.rs registers all 9 commands (5 Phase 1 + 4 Phase 2) in generate_handler
    - propose_groups reads threshold from settings table with 0.65 default
    - confirm_groups delegates to store with transaction safety
    - `cargo check` succeeds
  </done>
</task>

</tasks>

<verification>
1. `cd src-tauri && cargo test groups` — store CRUD tests pass
2. `cd src-tauri && cargo check` — full project compiles with all 9 registered commands
3. `grep "song_groups" src-tauri/src/store/migrations.rs` — Phase 2 migration present
4. `grep "propose_groups" src-tauri/src/main.rs` — command registered
5. `grep "grouping_threshold" src-tauri/src/commands/groups.rs` — configurable threshold wired
</verification>

<success_criteria>
- song_groups and group_files tables created by migration (idempotent with IF NOT EXISTS)
- confirm_groups uses SQLite transaction for atomic batch insert
- 4 new Tauri commands registered and callable from frontend
- Configurable threshold (0.65 default) read from settings table
- All 9 commands (Phase 1 + Phase 2) registered in main.rs
- Unit tests pass for group persistence round-trip
- cargo check succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-grouping/02-03-SUMMARY.md`
</output>
