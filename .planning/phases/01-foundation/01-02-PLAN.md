---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on: [01]
files_modified:
  - src-tauri/src/parser/flp.rs
  - src-tauri/src/parser/events.rs
  - src-tauri/src/parser/mod.rs
  - src-tauri/src/parser/types.rs
  - tests/sample_files/README.md
autonomous: true
requirements:
  - PARS-02
  - PARS-03
  - PARS-04
  - PARS-05

must_haves:
  truths:
    - "Parser extracts BPM from both modern (event 156) and legacy (event 66) FLP files"
    - "Parser extracts channel names and plugin names from FLP event stream"
    - "Parser extracts pattern count by counting FLP_NewPat events"
    - "Parser skips unknown event IDs without error or panic"
    - "Parser returns partial metadata with warnings for partially-readable files"
    - "Parser rejects non-FLP files with clear error (wrong magic bytes)"
  artifacts:
    - path: "src-tauri/src/parser/flp.rs"
      provides: "Top-level parse_flp function"
      exports: ["parse_flp"]
      min_lines: 100
    - path: "src-tauri/src/parser/events.rs"
      provides: "Event ID constants and varint reader"
      exports: ["read_varint", "EVENT_*"]
    - path: "src-tauri/src/parser/types.rs"
      provides: "FlpMetadata, ChannelInfo, ParseError types"
      exports: ["FlpMetadata", "ChannelInfo", "ParseError"]
  key_links:
    - from: "src-tauri/src/parser/flp.rs"
      to: "src-tauri/src/parser/events.rs"
      via: "uses event constants and varint reader"
      pattern: "events::"
    - from: "src-tauri/src/parser/flp.rs"
      to: "src-tauri/src/parser/types.rs"
      via: "returns FlpMetadata"
      pattern: "FlpMetadata"
---

<objective>
Implement the FLP binary parser using TDD — the core value engine of the entire app. Parser reads .flp binary format and extracts BPM, time signature, channel names, plugin IDs, pattern count, and FL Studio version.

Purpose: This is the single most critical component. Every downstream feature (grouping, browsing, diff) depends on accurate metadata extraction. TDD ensures correctness against the binary format.
Output: A tested `parse_flp(&[u8]) -> Result<FlpMetadata, ParseError>` function that handles modern and legacy FLP formats.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-CONTEXT.md

<interfaces>
From src-tauri/src/parser/types.rs (created in Plan 01):
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct FlpMetadata {
    pub bpm: Option<f32>,
    pub time_sig_num: Option<u8>,
    pub time_sig_den: Option<u8>,
    pub channel_count: u16,
    pub pattern_count: u16,
    pub mixer_track_count: u16,
    pub generators: Vec<ChannelInfo>,
    pub effects: Vec<String>,
    pub fl_version: Option<String>,
    pub warnings: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ChannelInfo {
    pub name: String,
    pub plugin_name: Option<String>,
    pub channel_type: u8,
}
```
</interfaces>
</context>

<feature>
  <name>FLP Binary Parser</name>
  <files>src-tauri/src/parser/flp.rs, src-tauri/src/parser/events.rs, src-tauri/src/parser/types.rs</files>
  <behavior>
    The parser takes raw bytes and returns structured metadata.

    **Header parsing:**
    - Input: bytes starting with b"FLhd" -> extracts format version, num_channels (u16 LE at offset 10), ppq
    - Input: bytes NOT starting with b"FLhd" -> returns ParseError::InvalidMagic

    **Event stream parsing (after b"FLdt" + size):**
    - Event ID 0-63: read 1 byte value (BYTE events)
    - Event ID 64-127: read 2 byte value LE (WORD events)
    - Event ID 128-191: read 4 byte value LE (DWORD events)
    - Event ID 192-255: read varint length, then read that many bytes (variable events)

    **Specific event extraction:**
    - Event 156 (DWORD): BPM = value / 1000.0 (modern FL Studio 10+)
    - Event 66 (WORD): BPM = value as f32 (legacy FL Studio 4-9, fallback if 156 not seen)
    - Event 64 (WORD): FLP_NewChan — flush current channel, start new one
    - Event 21 (BYTE): FLP_ChanType — set current channel type
    - Event 192 (TEXT): FLP_Text_ChanName — name current channel
    - Event 201 (TEXT): FLP_Text_PluginName — plugin name for current channel
    - Event 65 (WORD): FLP_NewPat — increment pattern count
    - Event 199 (TEXT): FLP_Version — FL Studio version string
    - All other events: skip silently (PARS-05 forward compatibility)

    **String decoding:**
    - If payload has alternating null bytes or starts with BOM: decode as UTF-16 LE
    - Otherwise: decode as UTF-8, replace invalid bytes
    - Strip trailing null bytes

    **Sanity checks:**
    - BPM outside 1.0-999.0: add warning, set to None
    - Channel count > 999: add warning

    **Edge cases:**
    - Truncated file mid-event: return partial results with warning
    - No BPM event found: bpm = None, warning added
    - Empty event stream after header: return metadata from header only
  </behavior>
  <implementation>
    Use std::io::Cursor with byteorder crate for reading. Sequential event loop with match on event_id ranges. Maintain mutable state: current_channel, current_plugin_name, current_channel_type. Flush channel on FLP_NewChan and at end of stream.

    **events.rs**: Define event ID constants (FLP_NEW_CHAN = 64, FLP_NEW_PAT = 65, FLP_TEMPO_LEGACY = 66, FLP_CHAN_TYPE = 21, FLP_TEMPO = 156, FLP_TEXT_CHAN_NAME = 192, FLP_VERSION = 199, FLP_TEXT_PLUGIN_NAME = 201). Implement `read_varint(cursor) -> Result<u64>`.

    **flp.rs**: Implement `parse_flp(bytes: &[u8]) -> Result<FlpMetadata, ParseError>`. ParseError enum: InvalidMagic, TruncatedHeader, IoError(std::io::Error). Parse header first. Then loop through events. Return best-effort partial results on any mid-stream error.

    Write comprehensive unit tests using synthetic binary payloads. Construct minimal valid .flp byte arrays in tests:
    - Test: valid header with FLhd magic + 6 bytes
    - Test: modern BPM (event 156 with value 128000 -> 128.0 BPM)
    - Test: legacy BPM (event 66 with value 140 -> 140.0 BPM)
    - Test: modern BPM overrides legacy BPM when both present
    - Test: channel with name and plugin
    - Test: pattern count from multiple FLP_NewPat events
    - Test: unknown event ID skipped without error
    - Test: invalid magic returns ParseError::InvalidMagic
    - Test: truncated file returns partial results
    - Test: BPM outside sanity range produces warning
    - Test: FL Studio version string extraction
    - Test: UTF-16 LE string decoding
  </implementation>
</feature>

<verification>
1. `cd src-tauri && cargo test parser` — all parser tests pass
2. `cargo check` succeeds
3. Parser handles all event ID ranges correctly
4. Unknown events are silently skipped (PARS-05)
5. Partial results returned on truncation (best-effort parsing)
</verification>

<success_criteria>
- `parse_flp` extracts BPM from both event 156 and event 66
- Channel names and plugin names are extracted from event stream
- Pattern count is correct (counts FLP_NewPat events)
- Unknown event IDs are skipped without error
- Invalid magic bytes return ParseError::InvalidMagic
- Truncated files return partial FlpMetadata with warnings
- All unit tests pass with `cargo test parser`
- BPM sanity check (1.0-999.0) produces warnings for out-of-range values
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
